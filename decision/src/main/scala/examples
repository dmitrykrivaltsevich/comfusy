// Tri-almost-equi-partition:
 inf(A)=1 &&
 sup(A)=12 &&
 card(A)=12 &&
 card(B1) = card(B2) &&
 card(B2) = card(B3) &&
 B1 slt B2 &&
 B2 << B3 &&
 B1 subset A &&
 B2 subseteq A &&
 B3 subset A &&
 (card(B1) + card(B2) + card(B3) <= card(A)) &&
 (card(B1) + card(B2) + card(B3) >= |A| - 2)

 inf(A)=1 &&
 sup(A)=12 &&
 |A|=12 &&
 card(B1) = card(B2) &&
 B1 ** B2 == {} &&
 inf(B1) = inf(A) &&
 sup(B1) < inf(B2) &&
 B1 ++ B2 subseteq A &&
 card(B1) + card(B2) >= |A| - 1
 
 
  inf(A)=1 &&
 inf(B1) = inf(A)
 sup(A)=12 &&
 
 
 //
inf(A)=1 &&
sup(A)=12 &&
|A| = 12 &&
(B1 ++ B2 ++ B3) seq A &&
B1 << B2 &&
B2 << B3 &&
|B1| = |B2| &&
|B2| = |B3|
 
// Paper example1: (225 -> 64 -> 20 orderings)
!(
 (sup(L) < v &&
 v < inf(R) &&
 e < v) => ( e in L ++ X ++ R <=> e in L)) && card(X) = 1 && v in X

// Paper example1, custom: (76 -> 64 -> 20 orderings)
!(
 (sup(L) < inf(R) && 
 sup(L) < v &&
 v < inf(R) &&
 e < v) => ( e in L ++ X ++ R <=> e in L)) && X seq {v}

// Paper example1, satisfiable: (236 -> 88 -> 24 orderings)
!(
 (sup(L) < v &&
 v < inf(R) &&
 e <= v) => ( e in L ++ X ++ R <=> e in L)) && X seq {v} 

 
// Paper example2: (6267 orderings)
!(
  (C seq L ++ {v} ++ R &&
   sup(L) < v &&
   v < inf(R)) =>
   ({v} seq lrange(C,card(L)+1, card(L)+1)))
   
// Paper example2: (2840 orderings)
!(
  (C seq L ++ X ++ R &&
   supL = sup(L) &&
   infL = inf(L) &&
   supX = v &&
   infX = v &&
   supR = sup(R) &&
   infR = inf(R) &&
   supC = sup(C) &&
   infC = inf(C) &&
   supL < v &&
   v < infR && 
   supL < infR && 
   infL >= infC && 
   infX >= infC && 
   infR >= infC && 
   supL <= supC && 
   supX <= supC && 
   supR <= supC) =>
   (X seq lrange(C,card(L)+1, card(L)+1))) && card(X) = 1 && v in X

// Paper example2, custom: (768 -> 768 -> 193 orderings)
!(
  (C seq L ++ {v} ++ R &&
   sup(L) < v &&
   v < inf(R) && 
   inf(C) = inf(L) && 
   sup(C) = sup(R))=>
   ({v} seq lrange(C,card(L)+1, card(L)+1)))

   
// Paper example3: (184 -> 184 -> 127 orderings)
!(((Above seq {} || pivot < inf(Above)) &&
  !(e <= pivot) && Above1 seq Above ++ X) => pivot < inf(Above1)) && |X|=1 && e in X

  
// Circular ordering: (known bug -> unhandled exception -> 6 orderings)
!((A ++ B seq C && A << B) <=> (A subseteq C && B seq C -- A && A << B))

// Byzantine Fault Tolerant example: (-)
!((
      n > 3 &&
      f > 0 &&
      n > f * 3 &&
      card(Servers) = n &&
      (Byz subseteq Servers) &&
      |Byz| = f &&
      (Corr seq Servers -- Byz) &&
      (S subseteq  Servers) &&
      |S| > f
    ) => (
      |Corr ** S| > 0
    ))

// (srv selem Corr) && (srv selem S) &&




// Zig-step
!((      sup(A1) < v2 &&
 	v2 < inf(A2) &&
 	(A1 ++ V2 ++ A2) << V1 &&
 	v2 < v1 &&
 	v1 < inf(A3)
 ) => (
 	inf(A1) < v2 &&
 	V2 slt (A2 ++ V1 ++ A3) &&
 	sup(A2) < v1 &&
 	v1 < inf(A3)
 )
 ) && (V1 seq {v1}) && (V2 seq {v2}) 
 
// Zig-step (Mod)
!((      sup(A1) < v2 &&
 	v2 < inf(A2) &&
 	(A1 ++ {v2} ++ A2) << {v1} &&
	sup(A2) < v1 &&
 	v2 < v1 &&
 	v1 < inf(A3)
 ) => (
 	inf(A1) < v2 &&
 	{v2} slt (A2 ++ {v1} ++ A3) &&
 	sup(A2) < v1 &&
 	v1 < inf(A3)
 )
 )
 
 
 
 !((     sup(A1) < v2 &&
 	v2 < inf(A2) &&
 	(A1 ++ V2 ++ A2) << V1 &&
 	v2 < v1
 ) => (
 	inf(A1) < v2 &&
 	V2 slt (A2 ++ V1 ++ A3) &&
 	sup(A2) < v1 &&
 	v1 < inf(A3)
 )
 ) && (V1 seq {v1}) && (V2 seq {v2}) 

// If an element larger then all elements is added to a collection, then it is 
// the maximal element of the set
// (62 orderings with Z3 called at every leaf)
!(
   ( 
      S seq (X ++ Y) &&
      Y ** X seq {} &&
      e >= sup(Y)
   )
    => sup(S) = e
) && X seq {e}

// (76 orderings with Z3 called at every leaf)
!(
   (  S seq ({e} ++ Y) &&
      e >= sup(Y)
   )
   => sup(S) = e
)


!(
   (  S seq ({e} ++ Y) &&
      e >= sup(Y)
   )
   => sup(S) > sup(Y)
)


